classdef VideoStitch <handle
    %VIDEOSTITCH Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        % inputs
        seqA;
        seqB;
        
        % Dimensions
        nFrames;
        
        videoHeight;
        videoWidth;
        
        meshSize;
        
        quadHeight;
        quadWidth;
        
        % correspondence
        maxppf;
        ppf; % points per frame
        CP; % Control Points
        validCP; 
        nCP;
        
        % optimization parameters
        span;
        smoothness;
        cropping;
        stableW;
        gap;
        
        % Optimization data
        Pa;
        Pb;
        Pa_inv;
        Pb_inv;
        Ca;
        Cb;
        Ca_inv;
        Cb_inv;
        H;
        
        Offset;
        
        % Tuples for building sparse matrix
        % 3 types of quadratic term
        % Pt = Ct
        % 
        % 
        % Pt = Pr
        % Pa*CPa = H*Pb*CPb
        % <x, y, z> = H*P*<x, y, z>
        
        % options
        useImage;
        
        % Others 
        
        % a2b2 for Pt - Ct
        % C^(-1) * corners
        CaCorner; %zeros(obj.nFrames, obj.meshSize, obj.meshSize, 4, 2);
        CbCorner;
        PaCorner;
        PbCorner;
        % C^(-1) * CP
        CaCP;
        CbCP;
        
        w_a;
        w_b;
       
    end
    
    methods
        function obj = VideoStitch(seqA, seqB, pathA, pathB, ControlPoints, ppf, UseImageSeq, smoothness, cropping)
            obj.seqA = seqA;
            obj.seqB = seqB;
            obj.Ca = pathA;
            obj.Cb = pathB;
            obj.Pa = obj.Ca;
            obj.Pb = obj.Cb;
            obj.CP = ControlPoints;
            obj.smoothness = smoothness;
            obj.cropping = cropping;
            obj.useImage = UseImageSeq;
            obj.stableW = 0;
            obj.span = 60;
            obj.H = eye(3);
            if UseImageSeq
                fileList = dir(seqA);
                fileList = fileList(3:length(fileList));
                obj.nFrames = length(fileList);
                if obj.nFrames < 2
                    error('Wrong inputs directory') ;
                end
                fileList = dir(seqB);
                fileList = fileList(3:length(fileList));
                if obj.nFrames ~= length(fileList)
                    error('Input length  doesn"t match') ;
                end
                frame = imread([seqB fileList(1).name]);
            else
                video = VideoReader(seqA);
                if hasFrame(video)
                    frame = readFrame(video);
                end
            end
            [obj.videoHeight, obj.videoWidth, ~] = size(frame);
            [~, obj.meshSize, ~, ~, ~] = size(pathA);
            [~, obj.meshSize, ~, ~, ~] = size(pathB);
            [obj.nFrames, obj.maxppf, ~] = size(obj.CP);
            obj.ppf = ppf;
            obj.validCP = zeros(obj.nFrames, obj.maxppf);
            obj.nCP = sum(ppf);
            obj.quadHeight = obj.videoHeight / obj.meshSize;
            obj.quadWidth = obj.videoWidth / obj.meshSize;
            
            
            
            %compute C_inv
            obj.Ca_inv = zeros(size(obj.Ca));
            obj.Cb_inv = zeros(size(obj.Cb));
            
            
            obj.CaCP = zeros(obj.nFrames, obj.maxppf, 3);
            obj.CbCP = obj.CaCP;
            
            obj.w_a = zeros(obj.nFrames, obj.nFrames, obj.meshSize, obj.meshSize);
            obj.w_b = zeros(obj.nFrames, obj.nFrames, obj.meshSize, obj.meshSize);
        end
        
        function [Pa_inv, Pb_inv] = inverse(obj, Pa, Pb)
            Pa_inv = zeros(size(Pa));
            Pb_inv = zeros(size(Pb));
            for frameIndex = 1:obj.nFrames
                for i = 1:obj.meshSize
                    for j = 1:obj.meshSize
                        Pa_inv(frameIndex, i, j, :, :) = squeeze(Pa(frameIndex, i, j, :, :))^(-1);                         
                        Pb_inv(frameIndex, i, j, :, :) = squeeze(Pb(frameIndex, i, j, :, :))^(-1);   
                    end
                end
            end
        end
        
        function [PaCorner, PbCorner] = PxCorner(obj, Pa_inv, Pb_inv)
            PaCorner = ones(obj.nFrames, obj.meshSize, obj.meshSize, 4, 3);
            PbCorner = ones(obj.nFrames, obj.meshSize, obj.meshSize, 4, 3);
            for frameIndex = 1:obj.nFrames
                for i = 1:obj.meshSize
                    for j = 1:obj.meshSize
                        [PaCorner(frameIndex, i, j, 1, 1), PaCorner(frameIndex, i, j, 1, 2)]...
                            = obj.transform([(j - 1) * obj.quadWidth + 1 (i - 1) * obj.quadHeight + 1], squeeze(Pa_inv(frameIndex, i, j, :, :))); 
                        [PaCorner(frameIndex, i, j, 2, 1), PaCorner(frameIndex, i, j, 2, 2)]...
                            = obj.transform([(j) * obj.quadWidth (i - 1) * obj.quadHeight + 1], squeeze(Pa_inv(frameIndex, i, j, :, :)));
                        [PaCorner(frameIndex, i, j, 3, 1), PaCorner(frameIndex, i, j, 3, 2)]...
                            = obj.transform([(j - 1) * obj.quadWidth + 1 (i) * obj.quadHeight], squeeze(Pa_inv(frameIndex, i, j, :, :)));
                        [PaCorner(frameIndex, i, j, 4, 1), PaCorner(frameIndex, i, j, 4, 2)]...
                            = obj.transform([(j) * obj.quadWidth (i) * obj.quadHeight], squeeze(Pa_inv(frameIndex, i, j, :, :)));
                        [PbCorner(frameIndex, i, j, 1, 1), PbCorner(frameIndex, i, j, 1, 2)]...
                            = obj.transform([(j - 1) * obj.quadWidth + 1 (i - 1) * obj.quadHeight + 1], squeeze(Pb_inv(frameIndex, i, j, :, :))); 
                        [PbCorner(frameIndex, i, j, 2, 1), PbCorner(frameIndex, i, j, 2, 2)]...
                            = obj.transform([(j) * obj.quadWidth (i - 1) * obj.quadHeight + 1], squeeze(Pb_inv(frameIndex, i, j, :, :)));
                        [PbCorner(frameIndex, i, j, 3, 1), PbCorner(frameIndex, i, j, 3, 2)]...
                            = obj.transform([(j - 1) * obj.quadWidth + 1 (i) * obj.quadHeight], squeeze(Pb_inv(frameIndex, i, j, :, :)));
                        [PbCorner(frameIndex, i, j, 4, 1), PbCorner(frameIndex, i, j, 4, 2)]...
                            = obj.transform([(j) * obj.quadWidth (i) * obj.quadHeight], squeeze(Pb_inv(frameIndex, i, j, :, :)));
                    end
                end
            end
        end
        
        function init(obj)
            obj.Pa = obj.Ca;
            obj.Pb = obj.Cb;
            
            [obj.Ca_inv, obj.Cb_inv] = obj.inverse(obj.Ca, obj.Cb);
            [obj.Pa_inv, obj.Pb_inv] = obj.inverse(obj.Pa, obj.Pb);    
            
            [obj.CaCorner, obj.CbCorner] = obj.PxCorner(obj.Ca_inv, obj.Cb_inv);
            [obj.PaCorner, obj.PbCorner] = obj.PxCorner(obj.Pa_inv, obj.Pb_inv);
            
            for frameIndex = 1:obj.nFrames
                for k = 1:obj.ppf(frameIndex)
                    obj.CaCP(frameIndex, k, :) = obj.timesCa([obj.CP(frameIndex, k, 1) obj.CP(frameIndex, k, 2) frameIndex]);
                    obj.CbCP(frameIndex, k, :) = obj.timesCb([obj.CP(frameIndex, k, 3) obj.CP(frameIndex, k, 4) frameIndex]);
                    obj.validCP(frameIndex, k) = 1;
                end
            end
            obj.calcOmega();
            obj.nCP = sum(obj.ppf);
            fprintf('Number of Valid Control Points :%5d\n', obj.nCP);
        end
        
        function updateAll(obj)
            
            obj.updateH_simple();
            obj.updateCP();
            [obj.Pa_inv, obj.Pb_inv] = obj.inverse(obj.Pa, obj.Pb);
            [obj.PaCorner, obj.PbCorner] = obj.PxCorner(obj.Pa_inv, obj.Pb_inv);            
        end
        
        function updateOffset(obj, window)
            B = zeros(obj.nFrames, 3, 3);
            tPa = zeros(obj.nFrames, obj.meshSize, obj.meshSize, 3, 3);
            tPb = tPa;
            oPa = obj.Pa;
            oPb = obj.Pb;
            oCa = obj.Ca;
            ms = obj.meshSize;
            for frameIndex = 1:obj.nFrames
                for row = 1:ms
                    for col = 1:ms 
                        B1 = squeeze(oPa(frameIndex, row, col, :, :)) / squeeze(oCa(frameIndex, row, col, :, :));
                        B(frameIndex, :, :) = squeeze(B(frameIndex, :, :)) + B1 ./ B1(3,3); 
                    end
                end
            end
            nf = obj.nFrames;
            for frameIndex = 1:nf
                head = max(frameIndex - window, 1);
                tail = min(frameIndex + window, nf);
                offset = sum(B(head:tail, :, :)) / (tail - head + 1) / (ms * ms);
                for row = 1:ms
                    for col = 1:ms 
                        tPa(frameIndex, row, col, :, :) = squeeze(offset) \ squeeze(oPa(frameIndex, row, col, :, :));
                        tPb(frameIndex, row, col, :, :) = squeeze(offset) \ squeeze(oPb(frameIndex, row, col, :, :));
                    end
                end
                
            end
            obj.Pa = tPa;
            obj.Pb = tPb;
        end
        
        function optPath(obj, maxIte)
            % first round
            
            obj.optPa(1);
            obj.updateOffset(obj.span);
            obj.optPb(1);
            obj.updateAll();
            ite = 0;
            while ite < maxIte 
                ite = ite + 1;
                disp(['round#' int2str(ite)]);
                done1 = obj.optPa(ite - maxIte);
                obj.updateOffset(obj.span);
                done2 = obj.optPb(ite - maxIte);
                obj.updateAll();
                if done1 * done2 == 1
                    break; 
                end
            end
        end
        
        
     
        function done = optPa(obj, is1st)
            % get J and r
            % iteratively get updated Pa and Pb
            if is1st == 0
                maxIte = 30;
            else
                maxIte = 20;
            end
            
            boost = 1;
            done = 0;
            for ite = 1: maxIte
                fprintf('.');
                J = obj.computeJa(is1st);
                r = obj.computeRa(is1st);
                b = - J' * r;
                A = J' * J;
                dx = A \ b;
                obj.update('a', dx * boost);
                rr = r' * r;
                if ite == 1
                    minimum = rr;
                else
                    if abs(rr - minimum) < 1e4
                        disp('Pa opted');
                        if ite == 2
                            done = 1;
                        end
                        break; 
                    end
                    if minimum <= rr
                        boost = boost * 0.5;
                        obj.update('a', - dx * boost);
                    else
                        minimum = rr;
                    end                    
                end      
            end             
            if ite == maxIte
                disp('reached max iteration'); 
            end
        end
        
        function done = optPb(obj, is1st)
            % get J and r
            % iteratively get updated Pa and Pb
            if is1st == 0
                maxIte = 30;
            else
                maxIte = 20;
            end
            boost = 1;
            done = 0;
            for ite = 1: maxIte
                fprintf('.');
                J = obj.computeJb(is1st);
                r = obj.computeRb(is1st);
                b = - J' * r;
                A = J' * J;
                dx = A \ b;
                obj.update('b', dx * boost);
                rr = r' * r;
                if ite == 1
                    minimum = rr;
                else
                    if abs(rr - minimum) < 1e4
                        disp('Pb opted');
                        if ite == 2
                            done = 1;
                        end
                        break; 
                    end
                    if minimum <= rr
                        boost = boost * 0.5;
                        obj.update('b', - dx * boost);
                    else
                        minimum = rr;
                    end                    
                end      
            end             
            if ite == maxIte
                disp('reached max iteration'); 
            end
        end
        
        function update(obj, path, dx)
            if path == 'a'
                P = obj.Pa; 
            else
                P = obj.Pb;
            end
            for frameIndex = 1 : obj.nFrames
                for row = 1:obj.meshSize
                    for col = 1:obj.meshSize 
                        dx33 = reshape([dx(frameIndex * 8 - 7: frameIndex * 8) ; 0], [3,3]);
                        dx33 = dx33';
                        P(frameIndex, row, col, :, :) = squeeze(P(frameIndex, row, col, :, :)) + dx33; 
                    end
                end
            end
            if path == 'a'
                obj.Pa = P; 
            else
                obj.Pb = P;
            end
            [obj.Pa_inv, obj.Pb_inv] = obj.inverse(obj.Pa, obj.Pb);
            [obj.PaCorner, obj.PbCorner] = obj.PxCorner(obj.Pa_inv, obj.Pb_inv);
        end
        
        function updateH(obj)
            % compute H from Pa Ca Pb Cb and CP 
            PA = zeros(3, obj.nCP);
            PB = zeros(3, obj.nCP);
            CPcount = 0;
            for frameIndex = obj.span + 1 : obj.nFrames - obj.span
                cpa = squeeze(obj.CaCP(frameIndex, obj.validCP(frameIndex, :) == 1, :));
                cpb = squeeze(obj.CbCP(frameIndex, obj.validCP(frameIndex, :) == 1, :));
                % TODO
                PA(:, CPcount + 1 : CPcount + obj.ppf(frameIndex)) = squeeze(obj.Pa(frameIndex, 1, 1, :, :)) * cpa';
                PB(:, CPcount + 1 : CPcount + obj.ppf(frameIndex)) = squeeze(obj.Pb(frameIndex, 1, 1, :, :)) * cpb';
                CPcount = CPcount + obj.ppf(frameIndex);
            end
            [obj.H, ~] = EstimateHomographyByRANSAC(PA, PB, 0.001);
            obj.H = obj.H / obj.H(3, 3);
            obj.H = obj.H ^ (-1);
        end
        
        function updateH_simple(obj)
            % compute H from Pa Ca Pb Cb and CP 
            PA = zeros(3, obj.ppf(obj.span+1) + obj.ppf(obj.span+2));
            PB = zeros(3, obj.ppf(obj.span+1) + obj.ppf(obj.span+2));
            CPcount = 0;
            for frameIndex = obj.span : obj.span + 2
                cpa = squeeze(obj.CaCP(frameIndex, obj.validCP(frameIndex, :) == 1, :));
                cpb = squeeze(obj.CbCP(frameIndex, obj.validCP(frameIndex, :) == 1, :));
                % TODO
                PA(:, CPcount + 1 : CPcount + obj.ppf(frameIndex)) = squeeze(obj.Pa(frameIndex, 1, 1, :, :)) * cpa';
                PB(:, CPcount + 1 : CPcount + obj.ppf(frameIndex)) = squeeze(obj.Pb(frameIndex, 1, 1, :, :)) * cpb';
                CPcount = CPcount + obj.ppf(frameIndex);
            end
            [obj.H, ~] = EstimateHomographyByRANSAC(PA, PB, 0.001);
            obj.H = obj.H / obj.H(3, 3);
            obj.H = obj.H ^ (-1);
        end
        
        function updateCP(obj)
            % set validCp and ppf according to H
%             threshold = 0.06 * obj.videoWidth / ite;
            obj.ppf = zeros(obj.nFrames, 1);
            for frameIndex = 1:obj.nFrames
                d = zeros(obj.maxppf, 1);
                for k = 1:obj.maxppf
                    if obj.validCP(frameIndex, k) == 0
                        break;
                    end
                    pb = obj.CP(frameIndex, k, 3:4);
                    rowb = floor((pb(1) - 0.001) / obj.quadWidth) + 1;
                    colb = floor((pb(2) - 0.001) / obj.quadHeight) + 1;
                    pa = obj.CP(frameIndex, k, 1:2);
                    rowa = floor((pa(1) - 0.001) / obj.quadWidth) + 1;
                    cola = floor((pa(2) - 0.001) / obj.quadHeight) + 1;
                    [a2, b2] = obj.transform(obj.CbCP(frameIndex, k, 1:2), obj.H * squeeze(obj.Pb(frameIndex, rowb, colb, :, :)));
                    [a1, b1] = obj.transform(obj.CaCP(frameIndex, k, 1:2), squeeze(obj.Pa(frameIndex, rowa, cola, :, :)));
                    d(k) = sqrt((a1 - a2)^2 + (b1 - b2)^2);                            
                end
                dsort = sort(d(d ~= 0));
                threshold = mean(dsort(floor(length(dsort) / 4):floor(length(dsort) * 3/ 4)));
                threshold = max(threshold, 0.02 * obj.videoWidth);
                threshold = min(threshold, 0.08 * obj.videoWidth);
                obj.validCP(frameIndex, d <= threshold) = 1;
                obj.validCP(frameIndex, d == 0) = 0;
                obj.validCP(frameIndex, d > threshold) = 0;
                obj.ppf(frameIndex) = sum(obj.validCP(frameIndex, :));
                obj.validCP(frameIndex, d > threshold) = -1;
                if obj.ppf(frameIndex) < 10
                    obj.validCP(frameIndex, obj.validCP(frameIndex, :) ~= 0) = -1; 
                    obj.ppf(frameIndex) = 0;
                end
            end
            obj.nCP = sum(obj.ppf);
            fprintf('Number of Valid Control Points :%5d\n', obj.nCP);
        end
        
        function J = computeJa(obj, is1st)
            % get the last updated J matrix 
            rowCount = 0;
            itemCount = 0;
            if is1st == 1
                nItems = obj.nFrames * (1 + 2 * obj.span) * obj.meshSize * obj.meshSize * 4 * 2 * 8;
            else
                nItems = (obj.nCP + obj.nFrames * obj.meshSize * obj.meshSize * (1 + 2 * obj.span) * 4) * 2 * 8;
            end
            Jbuilder = zeros(nItems, 3);
            for frameIndex = 1 : obj.nFrames
                for row = 1: obj.meshSize
                    for col = 1 : obj.meshSize
                        for r = frameIndex - obj.span : frameIndex + obj.span
                            if r == frameIndex
                                weight = sqrt(obj.cropping);
                                values = obj.getSubJType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.CaCorner(frameIndex, row, col, 1, 1), obj.CaCorner(frameIndex, row, col, 1, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                                
                                values = obj.getSubJType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.CaCorner(frameIndex, row, col, 2, 1), obj.CaCorner(frameIndex, row, col, 2, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                                
                                values = obj.getSubJType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.CaCorner(frameIndex, row, col, 3, 1), obj.CaCorner(frameIndex, row, col, 3, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                                
                                values = obj.getSubJType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.CaCorner(frameIndex, row, col, 4, 1), obj.CaCorner(frameIndex, row, col, 4, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                            elseif r > 0 && r <= obj.nFrames
                                weight = sqrt(obj.smoothness * obj.w_a(frameIndex, r, row, col));
                                values = obj.getSubJType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.PaCorner(r, row, col, 1, 1), obj.PaCorner(r, row, col, 1, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                                
                                values = obj.getSubJType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.PaCorner(r, row, col, 2, 1), obj.PaCorner(r, row, col, 2, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                                
                                values = obj.getSubJType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.PaCorner(r, row, col, 3, 1), obj.PaCorner(r, row, col, 3, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                                
                                values = obj.getSubJType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.PaCorner(r, row, col, 4, 1), obj.PaCorner(r, row, col, 4, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                            end
                        end
                    end
                end
                if is1st ~= 1
                    for k = 1:obj.maxppf
                        if obj.validCP(frameIndex, k) == 1
                            weight = 1;
                            pa = obj.CP(frameIndex, k, 1:2);
                            rowa = floor((pa(1) - 0.001) / obj.quadWidth) + 1;
                            cola = floor((pa(2) - 0.001) / obj.quadHeight) + 1;

                            values = obj.getSubJType1(squeeze(obj.Pa(frameIndex, rowa, cola, :, :)), ...
                                obj.CaCP(frameIndex, k, 1), obj.CaCP(frameIndex, k, 2)) * weight;    
                            rowCount = rowCount + 1;
                            Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                            Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                            Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :);
                            itemCount = itemCount + 8;
                            rowCount = rowCount + 1;
                            Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                            Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                            Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :);
                            itemCount = itemCount + 8;
                        end                    
                    end
                end
            end
            Jbuilder(itemCount+1:length(Jbuilder), :) = [];
            if itemCount ~= size(Jbuilder, 1)
                error('?'); 
            end
            J = sparse(Jbuilder(:, 1), Jbuilder(:, 2), Jbuilder(:, 3), rowCount, obj.nFrames * 8, itemCount);
        end
        
        function J = computeJb(obj, is1st)
            % get the last updated J matrix 
            rowCount = 0;
            itemCount = 0;
            if is1st == 1
                nItems = obj.nFrames * obj.meshSize * obj.meshSize * (1 + 2 * obj.span) * 4 * 2 * 8;
            else
                nItems = (obj.nCP + obj.nFrames * obj.meshSize * obj.meshSize * (1 + 2 * obj.span) * 4) * 2 * 8;
            end
            Jbuilder = zeros(nItems, 3);
            for frameIndex = 1 : obj.nFrames 
                for row = 1: obj.meshSize
                    for col = 1 : obj.meshSize
                        for r = frameIndex - obj.span : frameIndex + obj.span
                            if r == frameIndex
                                weight = sqrt(obj.cropping);
                                values = obj.getSubJType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.CbCorner(frameIndex, row, col, 1, 1), obj.CbCorner(frameIndex, row, col, 1, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                                
                                values = obj.getSubJType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.CbCorner(frameIndex, row, col, 2, 1), obj.CbCorner(frameIndex, row, col, 2, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                                
                                values = obj.getSubJType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.CbCorner(frameIndex, row, col, 3, 1), obj.CbCorner(frameIndex, row, col, 3, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                                
                                values = obj.getSubJType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.CbCorner(frameIndex, row, col, 4, 1), obj.CbCorner(frameIndex, row, col, 4, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                            elseif r > 0 && r <= obj.nFrames
                                weight = sqrt(obj.smoothness * obj.w_b(frameIndex, r, row, col));
                                values = obj.getSubJType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.PbCorner(r, row, col, 1, 1), obj.PbCorner(r, row, col, 1, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                                
                                values = obj.getSubJType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.PbCorner(r, row, col, 2, 1), obj.PbCorner(r, row, col, 2, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                                
                                values = obj.getSubJType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.PbCorner(r, row, col, 3, 1), obj.PbCorner(r, row, col, 3, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                                
                                values = obj.getSubJType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.PbCorner(r, row, col, 4, 1), obj.PbCorner(r, row, col, 4, 2));
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :) * weight;
                                itemCount = itemCount + 8;
                                rowCount  = rowCount + 1;
                                Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                                Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                                Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :) * weight;
                                itemCount = itemCount + 8;
                            end
                        end
                    end
                end
                if is1st ~= 1
                    for k = 1:obj.maxppf
                        if obj.validCP(frameIndex, k) == 1
                            weight = 1;
                            pb = obj.CP(frameIndex, k, 3:4);
                            rowb = floor((pb(1) - 0.001) / obj.quadWidth) + 1;
                            colb = floor((pb(2) - 0.001) / obj.quadHeight) + 1;

                            values = obj.getSubJType1(squeeze(obj.Pb(frameIndex, rowb, colb, :, :)), ...
                                obj.CbCP(frameIndex, k, 1), obj.CbCP(frameIndex, k, 2)) * weight;    

                            rowCount = rowCount + 1;
                            Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                            Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                            Jbuilder(itemCount + 1:itemCount + 8, 3) = values(1, :);
                            itemCount = itemCount + 8;
                            rowCount = rowCount + 1;
                            Jbuilder(itemCount + 1:itemCount + 8, 1) = rowCount;
                            Jbuilder(itemCount + 1:itemCount + 8, 2) = frameIndex * 8 - 7 : frameIndex * 8;
                            Jbuilder(itemCount + 1:itemCount + 8, 3) = values(2, :);
                            itemCount = itemCount + 8;
                        end
                    end
                end
            end
            Jbuilder(itemCount+1:length(Jbuilder), :) = [];
            if itemCount ~= size(Jbuilder, 1)
                error('?'); 
            end
            J = sparse(Jbuilder(:, 1), Jbuilder(:, 2), Jbuilder(:, 3), rowCount, obj.nFrames * 8, nItems);
        end
                
        function subJ = getSubJType1(~, H, a, b)
            % for Pt - Ct and Pt - H
            H = H./ H(3,3);
            x = reshape(H', [9 1]);
            % return 2*8
            deno = a * x(7) + b * x(8) + 1;
            
            nume = a * x(1) + b * x(2) + x(3);
            subJ = zeros(2, 8);
            subJ(1, 1) = a / deno; subJ(1, 2) = b / deno; subJ(1, 3) = 1 / deno;
            subJ(1, 7) = - a * nume / deno^2; subJ(1, 8) = - b * nume / deno^2;
            
            nume = a * x(4) + b * x(5) + x(6);
            subJ(2, 4) = a / deno; subJ(2, 5) = b / deno; subJ(2, 6) = 1 / deno;
            subJ(2, 7) = - a * nume / deno^2; subJ(2, 8) = - b * nume / deno^2;
        end
        
        function subJ = getSubJType3(~, Ht, Hr, a, b)
            Ht = Ht./Ht(3,3);
            xt = reshape(Ht', [9 1]);
            Hr = Hr./Hr(3,3);
            xr = reshape(Hr', [9 1]);
            
            
            
            % return 2 * 2 * 8 
            subJ = zeros(2, 2, 8);
            denot = a * xt(7) + b * xt(8) + 1;
            denor = a * xr(7) + b * xr(8) + 1;
            
            numet = a * xt(1) + b * xt(2) + xt(3);
            numer = a * xr(1) + b * xr(2) + xr(3);
            subJ(1, 1, 1) = a / denot; subJ(1, 1, 2) = b / denot; subJ(1, 1, 3) = 1 / denot;
            subJ(1, 2, 1) = - a / denor; subJ(1, 2, 2) = - b / denor; subJ(1, 2, 3) = - 1 / denor;
            subJ(1, 1, 7) = - a * numet / denot^2; subJ(1, 1, 8) = - b * numet / denot^2;
            subJ(1, 2, 7) = a * numer / denor^2; subJ(1, 2, 8) = b * numer / denor^2;
            
            numet = a * xt(4) + b * xt(5) + xt(6);
            subJ(2, 1, 4) = a / denot; subJ(2, 1, 5) = b / denot; subJ(2, 1, 6) = 1 / denot;
            subJ(2, 1, 7) = - a * numet / denot^2; subJ(2, 1, 8) = - b * numet / denot^2;
            
            numer = a * xr(4) + b * xr(5) + xr(6);
            subJ(2, 2, 4) = - a / denor; subJ(2, 2, 5) = - b / denor; subJ(2, 2, 6) = -1 / denor;
            subJ(2, 2, 7) = a * numer / denor^2; subJ(2, 2, 8) = b * numer / denor^2;
            
        end
        
        function subJ = getSubJType2(~, Ht, Hr, at, bt, ar, br)
            Ht = Ht./Ht(3,3);
            xt = reshape(Ht', [9 1]);
            Hr = Hr./Hr(3,3);
            xr = reshape(Hr', [9 1]);
            
            
            
            % return 2 * 2 * 8 
            subJ = zeros(2, 2, 8);
            denot =at * xt(7) + bt * xt(8) + 1;
            denor =ar * xr(7) + br * xr(8) + 1;
            
            numet =at * xt(1) + bt * xt(2) + xt(3);
            numer =ar * xr(1) + br * xr(2) + xr(3);
            subJ(1, 1, 1) = at / denot; subJ(1, 1, 2) = bt / denot; subJ(1, 1, 3) = 1 / denot;
            subJ(1, 2, 1) = - ar / denor; subJ(1, 2, 2) = - br / denor; subJ(1, 2, 3) = - 1 / denor;
            subJ(1, 1, 7) = - at * numet / denot^2; subJ(1, 1, 8) = - bt * numet / denot^2;
            subJ(1, 2, 7) = ar * numer / denor^2; subJ(1, 2, 8) = br * numer / denor^2;
            
            numet = at * xt(4) + bt * xt(5) + xt(6);
            subJ(2, 1, 4) = at / denot; subJ(2, 1, 5) = bt / denot; subJ(2, 1, 6) = 1 / denot;
            subJ(2, 1, 7) = - at * numet / denot^2; subJ(2, 1, 8) = - bt * numet / denot^2;
            
            numer = ar * xr(4) + br * xr(5) + xr(6);
            subJ(2, 2, 4) = - ar / denor; subJ(2, 2, 5) = - br / denor; subJ(2, 2, 6) = -1 / denor;
            subJ(2, 2, 7) = ar * numer / denor^2; subJ(2, 2, 8) = br * numer / denor^2;
            
        end
        
        function Ra = computeRa(obj, is1st)
            % return a vector with the length of number of quadratic terms 
            if is1st
                Ra = zeros(obj.nFrames * obj.meshSize * obj.meshSize * (1 + 2 * obj.span) * 4 * 2, 1);
            else
                Ra = zeros((obj.nFrames * obj.meshSize * obj.meshSize * (1 + 2 * obj.span) * 4 + obj.nCP)* 2, 1);
            end
            rowCount = 0;
            for frameIndex = 1 : obj.nFrames
                for row = 1: obj.meshSize
                    for col = 1 : obj.meshSize
                        for r = frameIndex - obj.span : frameIndex + obj.span
                            if r == frameIndex
                                % P -C
                                weight = sqrt(obj.cropping);
                                rowCount = rowCount + 2;
                                Ra(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.CaCorner(frameIndex, row, col, 1, 1), obj.CaCorner(frameIndex, row, col, 1, 2), ...
                                    (col - 1) * obj.quadWidth + 1, (row - 1) * obj.quadHeight + 1);
                                rowCount = rowCount + 2;
                                Ra(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.CaCorner(frameIndex, row, col, 2, 1), obj.CaCorner(frameIndex, row, col, 2, 2), ...
                                    col * obj.quadWidth, (row - 1) * obj.quadHeight + 1);
                                rowCount = rowCount + 2;
                                Ra(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.CaCorner(frameIndex, row, col, 3, 1), obj.CaCorner(frameIndex, row, col, 3, 2), ...
                                    (col - 1) * obj.quadWidth + 1, row * obj.quadHeight);
                                rowCount = rowCount + 2;
                                Ra(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.CaCorner(frameIndex, row, col, 4, 1), obj.CaCorner(frameIndex, row, col, 4, 2), ...
                                    col * obj.quadWidth, row * obj.quadHeight);
                            elseif r > 0 && r <= obj.nFrames
                                weight = sqrt(obj.smoothness * obj.w_a(frameIndex, r, row, col));
                                rowCount = rowCount + 2;
                                Ra(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.PaCorner(r, row, col, 1, 1), obj.PaCorner(r, row, col, 1, 2), ...
                                    (col - 1) * obj.quadWidth + 1, (row - 1) * obj.quadHeight + 1);
                                rowCount = rowCount + 2;
                                Ra(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.PaCorner(r, row, col, 2, 1), obj.PaCorner(r, row, col, 2, 2), ...
                                    col * obj.quadWidth, (row - 1) * obj.quadHeight + 1);
                                rowCount = rowCount + 2;
                                Ra(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.PaCorner(r, row, col, 3, 1), obj.PaCorner(r, row, col, 3, 2), ...
                                    (col - 1) * obj.quadWidth + 1, row * obj.quadHeight);
                                rowCount = rowCount + 2;
                                Ra(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pa(frameIndex, row, col, :, :)), ...
                                    obj.PaCorner(r, row, col, 4, 1), obj.PaCorner(r, row, col, 4, 2), ...
                                    col * obj.quadWidth, row * obj.quadHeight);
                            end
                        end
                
                    end
                end
                % PaCaCP - HPbCaC
                if is1st ~= 1
                    for k = 1:obj.maxppf
                        if obj.validCP(frameIndex, k) == 1
                            weight = 1;
                            pb = obj.CP(frameIndex, k, 3:4);
                            rowb = floor((pb(1) - 0.001) / obj.quadWidth) + 1;
                            colb = floor((pb(2) - 0.001) / obj.quadHeight) + 1;
                            pa = obj.CP(frameIndex, k, 1:2);
                            rowa = floor((pa(1) - 0.001) / obj.quadWidth) + 1;
                            cola = floor((pa(2) - 0.001) / obj.quadHeight) + 1;
                            rowCount = rowCount + 2;
                            [a2, b2] = obj.transform(obj.CbCP(frameIndex, k, 1:2), obj.H * squeeze(obj.Pb(frameIndex, rowb, colb, :, :)));
                            Ra(rowCount - 1:rowCount) = obj.get1rType1(squeeze(obj.Pa(frameIndex, rowa, cola, :, :)), ...
                                obj.CaCP(frameIndex, k, 1), obj.CaCP(frameIndex, k, 2), a2, b2) * weight;                            
                        end                        
                    end
                end
            end
            Ra(rowCount + 1:length(Ra)) = [];
        end
        
        function Rb = computeRb(obj, is1st)
            % return a vector with the length of number of quadratic terms 
            if is1st
                Rb = zeros(obj.nFrames * obj.meshSize * obj.meshSize * (1 + 2 * obj.span) * 4 * 2, 1);
            else
                Rb = zeros((obj.nFrames * obj.meshSize * obj.meshSize * (1 + 2 * obj.span) * 4 + obj.nCP)* 2, 1);
            end
            rowCount = 0;
            for frameIndex = 1 : obj.nFrames
                for row = 1: obj.meshSize
                    for col = 1 : obj.meshSize
                        for r = frameIndex - obj.span : frameIndex + obj.span
                            if r == frameIndex
                                % P -C
                                weight = sqrt(obj.cropping);
                                rowCount = rowCount + 2;
                                Rb(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.CbCorner(frameIndex, row, col, 1, 1), obj.CbCorner(frameIndex, row, col, 1, 2), ...
                                    (col - 1) * obj.quadWidth + 1, (row - 1) * obj.quadHeight + 1);
                                rowCount = rowCount + 2;
                                Rb(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.CbCorner(frameIndex, row, col, 2, 1), obj.CbCorner(frameIndex, row, col, 2, 2), ...
                                    col * obj.quadWidth, (row - 1) * obj.quadHeight + 1);
                                rowCount = rowCount + 2;
                                Rb(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.CbCorner(frameIndex, row, col, 3, 1), obj.CbCorner(frameIndex, row, col, 3, 2), ...
                                    (col - 1) * obj.quadWidth + 1, row * obj.quadHeight);
                                rowCount = rowCount + 2;
                                Rb(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.CbCorner(frameIndex, row, col, 4, 1), obj.CbCorner(frameIndex, row, col, 4, 2), ...
                                    col * obj.quadWidth, row * obj.quadHeight);
                            elseif r > 0 && r <= obj.nFrames
                                weight = sqrt(obj.smoothness * obj.w_b(frameIndex, r, row, col));
                                rowCount = rowCount + 2;
                                Rb(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.PbCorner(r, row, col, 1, 1), obj.PbCorner(r, row, col, 1, 2), ...
                                    (col - 1) * obj.quadWidth + 1, (row - 1) * obj.quadHeight + 1);
                                rowCount = rowCount + 2;
                                Rb(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.PbCorner(r, row, col, 2, 1), obj.PbCorner(r, row, col, 2, 2), ...
                                    col * obj.quadWidth, (row - 1) * obj.quadHeight + 1);
                                rowCount = rowCount + 2;
                                Rb(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.PbCorner(r, row, col, 3, 1), obj.PbCorner(r, row, col, 3, 2), ...
                                    (col - 1) * obj.quadWidth + 1, row * obj.quadHeight);
                                rowCount = rowCount + 2;
                                Rb(rowCount - 1:rowCount)= weight * obj.get1rType1(squeeze(obj.Pb(frameIndex, row, col, :, :)), ...
                                    obj.PbCorner(r, row, col, 4, 1), obj.PbCorner(r, row, col, 4, 2), ...
                                    col * obj.quadWidth, row * obj.quadHeight);
                            end
                        end
                    end
                end
                if is1st ~= 1
                    for k = 1:obj.maxppf
                        if obj.validCP(frameIndex, k) == 1
                            weight = 1;
                            pa = obj.CP(frameIndex, k, 1:2);
                            rowa = floor((pa(1) - 0.001) / obj.quadWidth) + 1;
                            cola = floor((pa(2) - 0.001) / obj.quadHeight) + 1;
                            pb = obj.CP(frameIndex, k, 3:4);
                            rowb = floor((pb(1) - 0.001) / obj.quadWidth) + 1;
                            colb = floor((pb(2) - 0.001) / obj.quadHeight) + 1;
                            rowCount = rowCount + 2;
                            [a2, b2] = obj.transform(obj.CaCP(frameIndex, k, 1:2), obj.H^(-1) * squeeze(obj.Pa(frameIndex, rowa, cola, :, :)));
                            Rb(rowCount - 1:rowCount) = obj.get1rType1(squeeze(obj.Pb(frameIndex, rowb, colb, :, :)), ...
                                obj.CbCP(frameIndex, k, 1), obj.CbCP(frameIndex, k, 2), a2, b2) * weight;
                        end                        
                    end
                end
            end
            Rb(rowCount + 1:length(Rb)) = [];
        end
        
        function dadb = get1rType1(obj, P, a1, b1, a2, b2)
            % P [a1, b1, 1] - [a2 b2 1] 
            [a3, b3] = obj.transform([a1, b1], P);
            da = a3 - a2;
            db = b3 - b2;
            dadb = [da; db];
        end
        
        function dadb = get1rType2(obj, Pt, Pr, at, bt, ar, br)
            % Pt [a1 b1 1] - Pr [a2 b2 1] 
            [a3, b3] = obj.transform([at, bt], Pt);
            [a4, b4] = obj.transform([ar, br], Pr);
            da = a3 - a4;
            db = b3 - b4;
            dadb = [da; db];
        end
        
                
        function render(obj, outPath, gap, marker, blend)
            if ~exist(outPath, 'dir')
                mkdir(outPath);
            end
            if obj.useImage
                 
            else
%                 videoA = VideoReader(obj.seqA);
%                 videoB = VideoReader(obj.seqB);                
%                 for i = 1:obj.span
%                     readFrame(videoA); 
%                     readFrame(videoB); 
%                 end
            end
            obj.gap = gap;
%             obj.gap = 0;
            row = 1; col = 1; % TODO
            obj.Offset = zeros(3);
            for frameIndex = 1:obj.nFrames
                obj.Offset = obj.Offset + inv(squeeze(obj.Pa(frameIndex, row, col, :, :)) * squeeze(obj.Ca_inv(frameIndex, row, col, :, :)));
            end
            obj.Offset = obj.Offset / obj.nFrames;
            obj.Offset = eye(3);
            parfor frameIndex =1:obj.nFrames 
                disp(['rendering: # ' int2str(frameIndex)]);
                if obj.useImage
                    fileListA = dir(obj.seqA);
                    fileListA = fileListA(3:length(fileListA));
                    fileListB = dir(obj.seqB);
                    fileListB = fileListB(3:length(fileListB));
                    fileNameA = fileListA(frameIndex).name;
                    fileNameB = fileListB(frameIndex).name;
                    IA = imread([obj.seqA fileNameA]);
                    IB = imread([obj.seqB fileNameB]);
                else
                    IA = readFrame(videoA);
                    IB = readFrame(videoB);
                end
                valid = squeeze(obj.CP(frameIndex, obj.validCP(frameIndex, :) == 1, :));
                notvalid = squeeze(obj.CP(frameIndex, obj.validCP(frameIndex, :) == -1, :));
                if marker
                    if size(valid, 2) ~= 1
                        IA = insertMarker(IA, valid(:, 1:2), 'color', 'green');
                        IB = insertMarker(IB, valid(:, 3:4), 'color', 'green');
                    end
                    if size(notvalid, 2) ~= 1
                        IA = insertMarker(IA, squeeze(obj.CP(frameIndex, obj.validCP(frameIndex, :) == -1,1:2)), 'color', 'red');
                        IB = insertMarker(IB, squeeze(obj.CP(frameIndex, obj.validCP(frameIndex, :) == -1,3:4)), 'color', 'red');
                    end
                end
                warpA = zeros(obj.videoHeight + 2 * obj.gap, obj.videoWidth + 2 * obj.gap, 3);
                warpB = zeros(obj.videoHeight + 2 * obj.gap, obj.videoWidth + 2 * obj.gap, 3);
                for i = 1:obj.meshSize
                    for j = 1:obj.meshSize
                        warpA = obj.warp1('a', frameIndex, i, j, IA, warpA); 
                        warpB = obj.warp1('b', frameIndex, i, j, IB, warpB); 
                    end
                end
                imwrite(uint8(warpA), [outPath '/A' int2str(frameIndex) '.png']);
                imwrite(uint8(warpB), [outPath '/B' int2str(frameIndex) '.png']);
                warpA = uint8(warpA); warpB = uint8(warpB);
                % obj.drawFeatures(obj.imwarp(frameIndex).cdata, obj.features(frameIndex));
                
%                 % asap
%                 cpa = squeeze(obj.CaCP(frameIndex, obj.validCP(frameIndex, :) == 1, :));
%                 cpb = squeeze(obj.CbCP(frameIndex, obj.validCP(frameIndex, :) == 1, :));
%                 % TODO
%                 PA = squeeze(obj.Pa(frameIndex, 1, 1, :, :)) * cpa'; PA(1,:) = PA(1,:) ./ PA(3, :) + obj.gap; PA(2,:) = PA(2,:) ./ PA(3, :) + obj.gap;
%                 PB = obj.H * squeeze(obj.Pb(frameIndex, 1, 1, :, :)) * cpb'; PB(1,:) = PB(1,:) ./ PB(3, :) + obj.gap; PB(2,:) = PB(2,:) ./ PB(3, :) + obj.gap;
% %                 [I1_features,I2_features]=SURF(warpA,warpB);
%                 asap = AsSimilarAsPossibleWarping(obj.videoHeight + 2*obj.gap,obj.videoWidth + 2*obj.gap, (obj.videoWidth + 2*obj.gap) / 16,(obj.videoHeight + 2*obj.gap) / 16,1);
%                 asap.SetControlPts(PB(1:2, :)',PA(1:2,:)');
%                 asap.Solve();
%                 warpB = asap.Warp(warpB, gap);
%                 warpA2 = zeros(obj.videoHeight + 2 * gap, obj.videoWidth + 2 * gap, 3);
%                 warpA2(gap + 1:obj.videoHeight + gap, gap + 1:obj.videoWidth + gap, :) = warpA;
%                 %
%                 warpA2(warpA2==0) = warpB(warpA2==0);
%                 warpB(warpB==0) = warpA2(warpB==0);
                if ~blend
                    warp = obj.imageBlending(warpA, warpB);
                else
                    warp = mblend3(warpA, warpB, 0.5);
                end
                imwrite(warp, [outPath '/' int2str(frameIndex) '.png']);
            end
        end
        
        function output_canvas = imageBlending(~, warped_img1,warped_img2)
    
            w1 = imfill(im2bw(uint8(warped_img1), 0),'holes');
            w2 = imfill(im2bw(uint8(warped_img2), 0),'holes');

            w1 = mat2gray(w1);
            w2 = mat2gray(w2);

            warped_img1 = double(warped_img1);
            warped_img2 = double(warped_img2);
            output_canvas(:,:,1) = ((warped_img1(:,:,1).*w1)+(warped_img2(:,:,1).*w2))./(w1+w2);
            output_canvas(:,:,2) = ((warped_img1(:,:,2).*w1)+(warped_img2(:,:,2).*w2))./(w1+w2);
            output_canvas(:,:,3) = ((warped_img1(:,:,3).*w1)+(warped_img2(:,:,3).*w2))./(w1+w2);
            output_canvas = uint8(output_canvas);
            
        end
        
        function imwarp = warp1(obj, aorb, frameIndex, location_i, location_j, source, imwarp)
            if aorb == 'a'
                P = obj.Pa; 
                C = obj.Ca;
            else
                P = obj.Pb;
                C = obj.Cb;
            end
            B = squeeze(P(frameIndex, location_i, location_j, :, :)) * squeeze(C(frameIndex, location_i, location_j, :, :))^(-1);
            if aorb == 'b'
                B = obj.H * B; 
            end
            B = obj.Offset * B;
            %B = B ./B(3,3);
            minx = (location_i - 1)*obj.quadHeight+1;
            maxx = minx + obj.quadHeight - 1;
            miny = (location_j - 1)*obj.quadWidth+1;
            maxy = miny + obj.quadWidth - 1;
            [x00, y00 ] = obj.transform([miny, minx], B);
            [x01, y01 ] = obj.transform([miny, maxx], B);
            [x10, y10 ] = obj.transform([maxy, minx], B);
            [x11, y11 ] = obj.transform([maxy, maxx], B);
            minx = min(x00, x01);minx = min(minx, x10);minx = min(minx, x11);
            miny = min(y00, y10);miny = min(miny, y01);miny = min(miny, y11);
            maxx = max(x10, x11);maxx = max(maxx, x01);maxx = max(maxx, x00);
            maxy = max(y01, y11);maxy = max(maxy, y10);maxy = max(maxy, y00);
            % imwarp = myWarp(minx, maxx, miny, maxy, double(source), obj.imwarp(frameIndex).cdata, inv(B), obj.gap);
            imwarp = myWarp(minx, maxx, miny, maxy, double(source), imwarp, inv(B), obj.gap);
        end
   
        
        
        function calcOmega(obj)
            disp('computing omega...')
            for i = 1:obj.meshSize
                for j = 1:obj.meshSize
                    for t = 1:obj.nFrames                        
                        for r = t-obj.span:t+obj.span
                            if r > 0 && r < obj.nFrames
                                dPa = abs(obj.Pa(t,i,j,1,3) - obj.Pa(r,i,j,1,3)) + abs(obj.Pa(t,i,j,2,3) - obj.Pa(r,i,j,2,3));
                                dPb = abs(obj.Pb(t,i,j,1,3) - obj.Pb(r,i,j,1,3)) + abs(obj.Pb(t,i,j,2,3) - obj.Pb(r,i,j,2,3));
                                obj.w_a(t,r,i,j) = gaussmf(abs(t-r), [10 0]) * gaussmf(dPa, [200 0]);
                                obj.w_b(t,r,i,j) = gaussmf(abs(t-r), [10 0]) * gaussmf(dPb, [200 0]);
                            end
                        end
                    end
                end
            end            
        end
        
        function [x,y] = transform(~, xxyy, B)
            xx = xxyy(1); yy = xxyy(2);
            res = B * [xx;yy;1];
            x = res(1)/res(3);
            y = res(2)/res(3);
        end
        
        function CaPa = timesCa(obj, Pa)
            %
            x = Pa(1); y = Pa(2); frameIndex = Pa(3);
            if (x * y) ~= 0
                i = floor((x - 0.0001) / obj.quadWidth) + 1;
                j = floor((y - 0.0001) / obj.quadHeight) + 1;
                [x, y] = obj.transform(Pa, squeeze(obj.Ca_inv(frameIndex, i, j, :, :)));
            end
            CaPa = ones(3, 1);
            CaPa(1) = x; CaPa(2) = y;
        end
        
        function CaPa = timesCb(obj, Pa)
            %
            x = Pa(1); y = Pa(2); frameIndex = Pa(3);
            if (x * y) ~= 0
                i = floor((x - 0.0001) / obj.quadWidth) + 1;
                j = floor((y - 0.0001) / obj.quadHeight + 1);
                [x, y] = obj.transform(Pa, squeeze(obj.Cb_inv(frameIndex, i, j, :, :)));
            end
            CaPa = ones(3, 1);
            CaPa(1) = x; CaPa(2) = y;
        end
        
    end
end

